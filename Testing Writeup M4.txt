checkEnemyColors: This unit test check that the three different types of enemies implemented do in fact have different colors. This test is relevant because it allows us to confirm that our game GUI is visually consistant with our implementational intentions.
        
checkHealthFunctionalities: This unit test verifies that the health of the three different types of enemies can be propery accessed and altered. This test is relevant because it confirms that the classes for each type of enemy correctly extend the abstract Enemy class, which will allow us to to make changes to the enemies' stats as the game progresses.

checkStoreDisplayyAfterEnd: This unit test verifies that the player is not able to buy after the monument health is 0. This test is relevant because it confirms that the game is over after the monument has been destroyed by the enemy. 

checkStartCombatPrompt: This unit test verifies that there is a start combat button. This test is relevant because it ensures that we are prompted with the start combat button to begin the game on the game screen. 

checkDifferingHealth: This unit test creates an enemy of each type and checks that their healths are different. This is relevant because the types of enemies should differ in how much health they have.

checkReset: This unit test sets the difficulty, changes the money, and then resets the game to check that the money is changed back to the initial value. This test is relevant because the game needs to be reset properly after the player triggers a game over. 
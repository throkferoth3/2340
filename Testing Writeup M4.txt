checkEnemyColors: This unit test check that the three different types of enemies implemented do in fact have different colors. This test is relevant because it allows us to confirm that our game GUI is visually consistant with our implementational intentions.
        
checkHealthFunctionalities: This unit test verifies that the health of the three different types of enemies can be propery accessed and altered. This test is relevant because it confirms that the classes for each type of enemy correctly extend the abstract Enemy class, which will allow us to to make changes to the enemies' stats as the game progresses.

checkStoreDisplayyAfterEnd: This unit test verifies that the player is not able to buy after the monument health is 0. This test is relevant because it confirms that the game is over after the monument has been destroyed by the enemy. 

checkStartCombatPrompt: This unit test verifies that there is a start combat button. This test is relevant because it ensures that we are prompted with the start combat button to begin the game on the game screen. 

checkInCombat: This unit test begins a round of combat and checks that the game correctly detects that it is in combat. This test is relevant because the game needs to change functionality depending on whether it is in combat.

checkGameOverReset: This unit test changes the difficulty and then resets the game to check that the difficulty is changed back to the initial value. This test is relevant because the game needs to be reset properly after the player triggers a game over. 